# Andastra.NET Rules for AI Agents

(2025 Edition – Optimized for LLM Performance & Compliance)

## 1. CRITICAL: ALWAYS COMMIT EVERY CHANGE

Commit format: Conventional Commits
`fix:`, `feat:`, `refactor:`, `docs:`, `chore:`, `test:`

**Rule #1 – Non-negotiable**
After ANY file change (create, modify, delete, move):

### Windows

```powershell
git add <file>; git commit -m "type(scope): message"  # NEVER git add . or -A; e.g. feat: add K2 camera system
```

### Linux/Mac (Unix)

```bash
git add <file> && git commit -m "type(scope): message"  # NEVER git add . or -A; e.g. feat: add K2 camera system
```

**Why this works for LLMs**: Clear, measurable, binary success/failure check. LLMs perform best with explicit "do this exact sequence" instructions.

**Why we chain with semicolon(;) and ampersand(&&)**: Other agents simultaneously might be committing, this prevents conflicts when multiple agents may be trying to add/commit to git simultaneously.

## 2. File Organization (Root Must Stay Clean)

- `docs/` – ALL .md except root `README.md`
- `scripts/` – ALL .ps1/.sh/.py/.bat
- Root only allowed: `README.md`, .sln, .csproj, .props, .gitignore, .cursor/rules

**Action**: If you see misplaced files → move them immediately → commit.

## 3. .NET Target Framework (Cross-Platform Only)

- Use ONLY: `net9.0`
- Otherwise, **Must have complementary platform support and conditional checks:**: `-windows`, `-linux`, `-macos`  e.g. `net9.0-windows` and whatever net9.0-windows equivalent is on mac/linux conditionally specified.

## 4. C# Language Version: 7.3 Maximum

**Hard limit**: C# 8+ features banned (nullable refs, switch expr, ranges, using decl, etc.)

**Rewrite pattern (if you see C# 8+)**:

- `string?` → `string` + `[CanBeNull]` (JetBrains.Annotations)
- `using var x = ...` → `using (var x = ...) { }`
- Switch expr → switch statement

### 4.1. Jetbrains.Annotations usage

- C# 7.3 doesn't support nullable reference types, so we use Jetbrains.Annotations to annotate nullable references.
- Example 1:

```csharp
[CanBeNull]
public string Name { get; set; }
```

- Example 2:

```csharp
[CanBeNull]  // may return null or a string (string? equivalent)
public string GetContent([NotNull] int index, [CanBeNull] object something = null)  // something may be null or an object
{
   // ... some logic here
}
```

## 5. Incomplete Code: ALWAYS Mark with `TODO:` + Type

```csharp
// TODO: STUB - Implement K2 event system (swkotor2.exe: 0x004eb750)
// TODO: PLACEHOLDER - Temporary GFF v3.3 (0x005ac670)
// TODO: FIXME - Memory leak in resource cache
// TODO: SIMPLIFIED - No pathfinding optimization yet
// TODO: HACK - Reflection workaround until API fixed
// TODO: STUB - A full implementation would require...
// TODO: STUB - For now, use ...
// TODO: This is a simplified...
```

**Why this works**: LLMs love searchability. `TODO:` + type + context is the gold standard for self-documenting code.

## 6. Architecture Rule – New Code vs Existing

**New code ONLY** (everything you write):
**Prefer conditional logic over inheritance**

```csharp
if (GameType == GameType.K2) { /* K2 behavior */ }
else if (GameType == GameType.K1) { /* K1 behavior */ }
```

**Existing code**: Leave inheritance alone. Never refactor it.
**Why**: LLMs get confused by "sometimes use inheritance, sometimes not". Clear rule: new = conditionals, old = keep as-is.

## 7. Resolving Name Conflicts in C# Projects

When encountering compilation errors due to ambiguous type references (e.g., multiple classes with the same name like `Game` in different namespaces), **always prioritize renaming one of the conflicting classes** to eliminate the ambiguity at the source.

- **Never use fully qualified names** (e.g., `Andastra.Parsing.Common.Game`) as a workaround in code or usings.
- **Never use alias directives** (e.g., `using Game = Andastra.Parsing.Common.Game;`) to resolve conflicts.
- Do not suggest or apply these temporary fixes.

#### Choosing Which Class to Rename

- Analyze the entire solution to determine how many references exist for each conflicting class.
- Count the occurrences of each class name in `using` statements, type declarations, instantiations, and other usages across all files.
- **Rename the class that appears in fewer places** — this will require the fewest code changes and minimize the risk of introducing new errors.
- If the counts are similar, prefer renaming the class from an external or less central namespace/library over one in your core project code.

#### Renaming Process

- Choose a clear, descriptive new name that avoids future conflicts (e.g., `AndastraGame` or `ParsingGame` based on context).
- Use the IDE's safe rename refactoring tool when possible to update all references automatically.
- After renaming, rebuild the solution and fix any remaining issues systematically.
- Batch related changes together for efficiency, and aim for a complete build success in each iteration.

Always plan changes carefully before applying them, considering the impact on the overall project structure and build.

## 8. Reverse Engineering Workflow (Mandatory)

1. Analyze in Ghidra first
2. Document in Ghidra: rename functions/vars, add comments, prototype
3. In C#: comment source of truth

   ```csharp
   // swkotor2.exe: 0x004eb750 – original engine behavior
   if (GameType == GameType.K2) { ... }
   ```

4. Use ghidra mcp to ensure 1:1 parity. Setup using mcp server tool 'open-project' on project path "C:\Users\boden\Andastra Ghidra Project.gpr"

**CRUCIALLY IMPORTANT**: If ghidra was requested/required for the task ensure it works before proceeding with the task. If it fails or a tool call doesn't work due to a connection error or setup error or not available or something, STOP **IMMEDIATELY** and INFORM the user.

## 9. NSS/NCS Operations

Use `scripts/NcsTool.ps1` for everything (compile, decompile, compare, roundtrip, generate-defs)

## 10. Documentation

- Only public-facing .md → `docs/`
- Progress reports must be standard roadmaps that are kept in .cursor/roadmaps/*.md
- Literally all documentation should be roadmaps in ./.cursor/roadmaps or public facing in ./docs

## 11. Definition of Done (Simple Checklist)

- Code compiles (no warnings)
- Uses C# 7.3
- Matches original behavior (Ghidra-verified)
- All changes committed
- Files in correct folders
- Uses `TODO:` for anything unfinished
