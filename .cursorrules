# HoloPatcher.NET Rules and Conventions for AI LLM agents

## ⚠️ CRITICAL: Git Commit Requirement ⚠️

**MANDATORY FOR ALL AI AGENTS**: After making ANY changes to files in this repository, you MUST:

1. **Stage all modified files**: `git add <file1> <file2> ...` (or `git add .` for all changes)
2. **Commit with a descriptive message**: `git commit -m "type: descriptive message"`
3. **Verify the commit succeeded**: Check that `git commit` returns successfully with no errors

**This is NOT optional.** Do NOT summarize changes without committing them. Do NOT skip this step. Every code change, file modification, or configuration update MUST be committed before you consider the task complete.

**NEVER use `git add .` or `git add -A` to stage changes.** Always stage files individually. This is because we may have multiple agents working on multiple files simultaneously.

**Commit message format**: Use conventional commits format:

- `fix:` for bug fixes
- `feat:` for new features
- `refactor:` for code refactoring
- `docs:` for documentation changes
- `chore:` for maintenance tasks
- `test:` for test changes

Example: `git commit -m "fix: correct finalize job condition in workflow"`

Note: root-level .git is different repo than ./src/Andastra/.git

---

## Documentation

When creating ANY new `.md` files, always follow these guidelines:

- Always place within `docs`
- Never report on progression (changes and what still remains to be done).
- Exclusively provide public-facing documentation, something an end user will need to read if they want to either develop for Andastra.NET or work with it.

Please do not create .md documentation unless it delivers public-facing information or authoritative gameplay/platform references that an end user or developer genuinely needs for PyKotor or the games themselves.

## Helper Scripts

- Always place within `scripts`
- Should be idempotent and flexible enough to be used for a plethora of scenarios, not just whatever the task you're working on involves.
- Do not delete helper .py/.ps1/.sh scripts when you are finished with them; keep them in scripts folder

## File Organization

**CRITICAL: Repository Root Cleanup**

AI agents MUST maintain proper file organization in the repository root:

1. **Documentation Files**:
   - ALL `.md` documentation files (except `README.md`) MUST be placed in `./docs`
   - `README.md` is the ONLY markdown file allowed in the repository root
   - When creating new documentation, always place it in `./docs`
   - If you find documentation files in the root (other than `README.md`), move them to `./docs`

2. **Script Files**:
   - ALL script files (`.ps1`, `.sh`, `.py`, `.bat`, `.cmd`, etc.) MUST be placed in `./scripts`
   - When creating new scripts, always place them in `./scripts`
   - If you find script files in the root, move them to `./scripts`

3. **Root Directory**:
   - The root directory should only contain:
     - `README.md` (the only allowed markdown file in root)
     - Solution files (`.sln`)
     - Project configuration files (`.csproj`, `.props`, etc.)
     - Build artifacts and temporary files (as appropriate)
     - Essential configuration files (`.gitignore`, `.cursorrules`, etc.)

**When creating or moving files, always verify they are in the correct location according to these rules.**

## C# Language Version Requirements

**CRITICAL: The maximum C# language version allowed is 7.3. NEVER upgrade to C# 8.0 or higher.**

This is a hard requirement for .NET Framework 4.x compatibility. The following C# 8+ features are FORBIDDEN:

- Nullable reference types (`string?`, `object?`, etc.)
- Switch expressions
- Using declarations (must use `using` blocks)
- Default interface implementations
- Async streams
- Indices and ranges (`^1`, `..`)
- Null-coalescing assignment (`??=`)
- Pattern matching enhancements (property patterns, tuple patterns, positional patterns)
- Static local functions

When fixing code, convert C# 8+ syntax to C# 7.3 compatible alternatives, including but not limited to:

- `string?` → `string` (use `[CanBeNull]` attribute if needed and add `using JetBrains.Annotations;` if not already present)
- `value!` → `value` (remove null-forgiving operator)
- Switch expressions → switch statements
- `using var x = ...` → `using (var x = ...) { }`
- `namespace SomeNamespace;` → `namespace SomeNamespace { ... }`

## Incomplete/Temporary Code Marking

**CRITICAL: All incomplete code MUST use `TODO:` prefix for searchability.**

**Marking Patterns:**

- **STUB**: Method signature exists, throws `NotImplementedException` with context

  ```csharp
  // TODO: STUB - Implement ProcessData (swkotor2.exe: 0x004eb750)
  throw new NotImplementedException("ProcessData: Reverse engineering in progress");
  ```

- **PLACEHOLDER**: Temporary implementation that works but needs replacement

  ```csharp
  // TODO: PLACEHOLDER - Replace with full GFF serialization (swkotor2.exe: 0x005ac670)
  ```

- **SIMPLIFIED**: Working implementation missing features/optimizations

  ```csharp
  // TODO: SIMPLIFIED - Add A* pathfinding optimization for large areas
  ```

- **FIXME**: Known bug or incorrect behavior requiring fix

  ```csharp
  // TODO: FIXME - Memory leak when disposing resources, needs investigation
  ```

- **HACK**: Workaround that should be replaced with proper solution

  ```csharp
  // TODO: HACK - Using reflection until API is fixed
  ```

**Requirements:**

- ALL incomplete code MUST start with `TODO:` followed by type (STUB/PLACEHOLDER/SIMPLIFIED/FIXME/HACK)
- Include context: what needs doing, why incomplete, relevant addresses/refs
- For reverse-engineered code: include executable and function address
- Be specific: avoid vague comments like "fix this" or "placeholder"
- Public APIs: use XML docs (`/// <summary>`) to document incomplete methods

## NCS/NSS File Operations

The `scripts` directory contains a comprehensive unified PowerShell tool for all NCS/NSS file operations:

### NcsTool.ps1

Unified tool for all NCS (bytecode) and NSS (source) file operations. Supports multiple operations via subcommands:

**Operations:**

- `compile`: Compile NSS source files to NCS bytecode
- `decompile`: Decompile NCS bytecode files to NSS source
- `compare`: Compare two NCS files (bytecode and/or instructions)
- `roundtrip`: Perform round-trip testing (NSS -> NCS -> NSS -> NCS -> Compare)
- `generate-defs`: Generate ScriptDefs.cs from nwscript.nss files

**Examples:**

```powershell
# Compile NSS to NCS
.\scripts\NcsTool.ps1 compile -InputPath "script.nss" -Game "k2"
.\scripts\NcsTool.ps1 compile -InputPath "C:\Scripts" -Recursive -LibraryLookup "C:\Includes" -Overwrite

# Decompile NCS to NSS
.\scripts\NcsTool.ps1 decompile -InputPath "script.ncs" -OutputPath "script.nss" -Game "k1"
.\scripts\NcsTool.ps1 decompile -InputPath "C:\NCS" -OutputPath "C:\Decompiled" -Recursive

# Compare two NCS files
.\scripts\NcsTool.ps1 compare -OriginalFile "original.ncs" -RoundTripFile "roundtrip.ncs" -CompareMode "bytecode" -Detailed
.\scripts\NcsTool.ps1 compare -OriginalFile "test.ncs" -RoundTripFile "test.rt.ncs" -CompareMode "both" -ShowOnly "both"

# Round-trip testing
.\scripts\NcsTool.ps1 roundtrip -InputPath "script.nss" -Game "k2"
.\scripts\NcsTool.ps1 roundtrip -InputPath "C:\Scripts" -Recursive -CompareMode "bytecode" -KeepIntermediate -StopOnFirstFailure

# Generate ScriptDefs.cs
.\scripts\NcsTool.ps1 generate-defs
```

The tool supports `-WhatIf` for dry-run testing, `-Verbose` for detailed output, and follows PowerShell best practices. It can process single files, multiple files, or entire directory trees recursively.

**CRITICAL: Ghidra MCP Usage for Andastra Code (Aurora/Eclipse/Infinity/Odyssey)**

When working on Andastra Engine code (anything in `src/Andastra/`), AI agents MUST:

1. **Use Ghidra MCP** for understanding original engine behavior:
   - Verify implementation faithfulness against original engine behavior
   - **MANDATORY: Cross-Engine Analysis and Inheritance Structure**:
     - **NEVER document a function without specifying which .exe it's from** (e.g., `swkotor2.exe: 0x004eb750`, `nwmain.exe: 0x14051d5c0`)
     - **CRITICAL: Base Class Implementation Workflow**:
       - **NEVER implement or document base classes (Runtime.Games.Common) until ALL engines have been reverse engineered**
       - **MANDATORY WORKFLOW for base classes**:
         1. **FIRST**: Search for and analyze equivalent functions in ALL engines (swkotor.exe, swkotor2.exe, nwmain.exe, daorigins.exe, DragonAge2.exe, MassEffect.exe, MassEffect2.exe)
         2. **SECOND**: Decompile and compare implementations across ALL engines to identify common patterns
         3. **THIRD**: Document findings in Ghidra for ALL engines with function addresses and analysis
         4. **FOURTH**: Only after complete cross-engine analysis, identify what is truly common across ALL engines
         5. **FIFTH**: Implement base class with ONLY common functionality (no engine-specific details)
         6. **SIXTH**: Implement engine-specific subclasses with engine-specific details
       - **Base classes MUST NOT contain**:
         - Engine-specific function addresses (e.g., `swkotor2.exe: 0x004eb750`)
         - Engine-specific implementation details
         - References to engine-specific file formats or systems
         - Any details that differ between engines
       - **Base classes MUST ONLY contain**:
         - Abstract methods/properties that all engines share
         - Common initialization patterns (if identical across all engines)
         - Shared interfaces and contracts
         - Generic documentation that applies to all engines
       - **Engine-specific details MUST be in subclasses**:
         - All Ghidra function addresses go in engine-specific subclasses
         - All engine-specific implementation details go in subclasses
         - All engine-specific file format references go in subclasses
     - **MANDATORY**: When finding ANY function in ANY engine, AI agents MUST:
       1. Search for similar/equivalent functions in ALL other engines (swkotor.exe, swkotor2.exe, nwmain.exe, daorigins.exe, DragonAge2.exe, MassEffect.exe, etc.)
       2. Decompile and compare implementations across engines to identify common patterns
       3. Document findings in Ghidra for ALL engines before implementing base classes
       4. Establish base class inheritance structure:
          - Create base classes in `Runtime.Games.Common` for shared functionality (ONLY after complete cross-engine analysis)
          - Create engine-specific implementations in `Runtime.Games.{Engine}` that inherit from base classes
          - Document which functions map to base class methods vs. engine-specific overrides
       5. Document inheritance structure in roadmap with format (example):
          - Base Class: `CommonScriptExecutor` (Runtime.Games.Common)
            - Odyssey: `OdysseyScriptExecutor : CommonScriptExecutor` (swkotor.exe: 0x..., swkotor2.exe: 0x...)
            - Aurora: `AuroraScriptExecutor : CommonScriptExecutor` (nwmain.exe: 0x...)
            - Eclipse: `EclipseScriptExecutor : CommonScriptExecutor` (daorigins.exe: 0x..., DragonAge2.exe: 0x...)
            - Infinity: `InfinityScriptExecutor : CommonScriptExecutor` (MassEffect.exe: 0x..., MassEffect2.exe: 0x...)

     - **MANDATORY**: When modifying ANY code in `src/Andastra/`, AI agents MUST:
       - **For base classes (Runtime.Games.Common)**:
         - MUST reverse engineer ALL engines first (Odyssey, Aurora, Eclipse)
         - MUST compare implementations across ALL engines
         - MUST only document common functionality (no engine-specific details)
         - MUST NOT include engine-specific function addresses or implementation details
       - **For engine-specific subclasses (Runtime.Games.{Engine})**:
         - Search Ghidra for related functions using string searches and function name searches in the relevant engine executable(s)
         - Decompile relevant functions to understand original implementation
         - Add detailed comments with Ghidra function addresses, executable name, and context
         - Use consistent comment format matching the MonoGame API documentation pattern
         - **ALWAYS specify the source executable** in comments (e.g., `swkotor2.exe: 0x004eb750`)
       - **PRIORITY**: When working on base classes, prioritize reverse engineering Aurora and Eclipse engines FIRST (they are less documented than Odyssey)
   - **MANDATORY: In-Ghidra Documentation**: AI agents MUST document findings directly within Ghidra
     - **Documentation must be comprehensive**: Every analyzed function should have:
       - Descriptive function name (not `FUN_004eb750`, but `SaveGlobalVariables` or similar)
       - Function prototype with correct parameter types and return types
       - Comments explaining what the function does, its purpose, and key implementation details
       - Renamed variables and data labels that reflect their actual purpose
       - Cross-references documented where relevant

2. **Reference Documentation**:
   - Primary: `vendor/PyKotor/wiki/` for file format documentation
   - Secondary: `vendor/PyKotor/vendor/xoreos-docs/` for official BioWare specs
   - Implementation plan: `.cursor/plans/monogame_odyssey_engine_e8927e4a.plan.md`
   - Roadmap: `docs/engine_roadmap.md`

### Engine Architecture Principles

**No Game Assets**: Runtime loads from user-provided game installations. Never ship game assets.

### Engine API Implementation

When implementing NWScript engine functions:

1. **Use ScriptDefs**: Reference `Andastra.Common.Script.ScriptDefs` for function signatures
2. **Profile separation**: K1 has ~850 functions, K2 has ~950 functions. dragon age origins/dragon age 2/mass effect 1/2 and nwn: ee are unfinished and HIGH priorities.

### Clean-Room Process

- Implementation is derived from behavioral observation and specification documents
- **No code copying** from other implementations
- Match original engine behavior exactly where documented
- Document any deviations or improvements
- Avoid GPL/LGPL/AGPL dependencies in shipped runtime

### Testing Requirements

- NCS VM: deterministic unit tests for all opcodes
- Resource precedence: synthetic mini-installation fixtures
- Content decoding: golden-file tests
- Vertical slice: playable integration tests

### Performance Budgets

- Module load (warm): seconds, not minutes
- Frame rate: stable 60fps on midrange GPU
- Script budget: capped instructions per frame
- Memory: bounded caches with LRU eviction

### Definition of Done for Engine Work

A feature is complete when:

- Implementation matches original engine behavior
- Unit tests meticulously written, and passing for deterministic logic
- Integration with Andastra format parsers works
- C# 7.3 syntax or lower, 8+ isn't supported.
- Code compiles with no warnings
